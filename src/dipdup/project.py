"""Scaffolding tools and scenarios for `dipdup new` command.

Ask user some question with Click; render Jinja2 templates with answers.
"""

import dataclasses
import logging
import re
from itertools import chain
from pathlib import Path
from typing import Any
from typing import get_args

from pydantic import ConfigDict
from pydantic import TypeAdapter
from pydantic.dataclasses import dataclass
from pydantic.fields import FieldInfo
from typing_extensions import TypedDict

from dipdup import __version__
from dipdup.cli import big_yellow_echo
from dipdup.cli import echo
from dipdup.config import DatabaseConfigU
from dipdup.config import DatasourceConfigU
from dipdup.config import RuntimeConfigU
from dipdup.config import ToStr
from dipdup.env import get_package_path
from dipdup.env import get_pyproject_name
from dipdup.utils import load_template
from dipdup.utils import write
from dipdup.yaml import DipDupYAMLConfig

_logger = logging.getLogger(__name__)

CODEGEN_HEADER = f'# generated by DipDup {__version__.split("+")[0]}'


# NOTE: All templates are stored in src/dipdup/projects
TEMPLATES: dict[str, tuple[str, ...]] = {
    'evm': (
        'demo_evm_events',
        'demo_evm_transactions',
        'demo_evm_uniswap',
    ),
    'starknet': ('demo_starknet_events',),
    'substrate': ('demo_substrate_events',),
    'tezos': (
        'demo_tezos_auction',
        'demo_tezos_dao',
        'demo_tezos_dex',
        'demo_tezos_domains',
        'demo_tezos_events',
        'demo_tezos_etherlink',
        'demo_tezos_factories',
        'demo_tezos_head',
        'demo_tezos_nft_marketplace',
        'demo_tezos_raw',
        'demo_tezos_token',
        'demo_tezos_token_balances',
        'demo_tezos_token_transfers',
    ),
    'other': ('demo_blank',),
}

# TODO: demo_jobs
# TODO: demo_backup
# TODO: demo_sql
# TODO: demo_timescale
# TODO: demo_cli


class Answers(TypedDict):
    """Answers for survey/replay in order of appearance"""

    dipdup_version: ToStr
    template: str
    package: str
    version: str
    description: str
    license: str
    name: str
    email: str
    postgres_image: str
    postgres_data_path: str
    hasura_image: str
    line_length: ToStr
    package_manager: str
    _survey_config: dict[str, Any] | None


def get_default_answers() -> Answers:
    return Answers(
        dipdup_version=__version__.split('.')[0],
        template='demo_blank',
        package='dipdup_indexer',
        version='0.0.1',
        description='A blockchain indexer built with DipDup',
        license='MIT',
        name='John Doe',
        email='john_doe@example.com',
        postgres_image='postgres:16',
        postgres_data_path='/var/lib/postgresql/data',
        hasura_image='hasura/graphql-engine:latest',
        line_length='120',
        package_manager='uv',
        _survey_config=None,
    )


def get_package_answers(package: str | None = None) -> Answers | None:
    if not package:
        package = get_pyproject_name()
    if not package:
        return None

    replay_path = get_package_path(package) / 'configs' / 'replay.yaml'
    if not replay_path.is_file():
        return None

    return answers_from_replay(replay_path)


@dataclass(config=ConfigDict(extra='forbid', defer_build=True), kw_only=True)
class ReplayConfig:
    spec_version: ToStr
    replay: Answers


def get_replay_path(name: str) -> Path:
    return Path(__file__).parent / 'projects' / name / 'replay.yaml'


def template_from_terminal() -> tuple[str | None, dict[str, Any] | None]:
    # _, mode = prompt_anyof(
    #     question='How would you like to set up your new DipDup project?',
    #     options=(
    #         'From template',
    #         'Interactively',
    #         'Blank',
    #     ),
    #     comments=(
    #         'Use one of demo projects',
    #         'Guided setup with prompts',
    #         'Begin with an empty project',
    #     ),
    #     default=0,
    # )
    mode = 'Interactively'

    if mode == 'Blank':
        return ('demo_blank', None)

    res = prompt_anyof(
        question='What blockchain are you going to index?',
        options=(
            'EVM',
            'Starknet',
            'Substrate',
            'Tezos',
            '[multiple]',
        ),
        comments=(
            'EVM-compatible',
            'Starknet',
            'Substrate',
            'Tezos',
            'Disable filtering',
        ),
        default=0,
    )
    namespace = res[1].lower() if res[1] != '[multiple]' else None

    if mode == 'Interactively':
        replay_path = get_replay_path('demo_blank')
        survey_config = query_survey_config(namespace)
        return ('demo_blank', survey_config)

    if mode == 'From template':
        options, comments = [], []
        templates = TEMPLATES[namespace] if namespace else chain(v for v in TEMPLATES.values())
        for name in templates:
            replay_path = get_replay_path(name)
            _answers = answers_from_replay(replay_path)
            options.append(_answers['template'])
            comments.append(_answers['description'])

        _, template = prompt_anyof(
            'Choose a project template:',
            options=tuple(options),
            comments=tuple(comments),
            default=0,
        )
        return (template, None)

    raise NotImplementedError


def answers_from_terminal(template: str | None) -> Answers:
    """Script running on dipdup new command and will create a new project base from interactive survey"""
    import survey  # type: ignore[import-untyped]

    big_yellow_echo(
        'Welcome to DipDup! This command will help you to create a new project.\n'
        'You can abort at any time by pressing Ctrl+C twice. Press Enter to use default value.'
    )

    answers = get_default_answers()

    if template:
        echo(f'Using template `{template}`\n')
    else:
        template, survey_config = template_from_terminal()
        answers['_survey_config'] = survey_config

    answers['template'] = template or 'demo_blank'

    big_yellow_echo('Set up project')

    while True:
        package = survey.routines.input(
            'Enter project name (the name will be used for folder name and package name): ',
            value=answers['package'],
        )
        if re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', package):
            break

        echo(
            f'"{package}" is not valid Python package name. Please use only letters, numbers and underscores.',
            fg='red',
        )

    answers['package'] = package
    answers['version'] = survey.routines.input(
        'Enter project version: ',
        value=answers['version'],
    )

    # NOTE: Used in pyproject.toml, README.md and some other places
    answers['description'] = survey.routines.input(
        'Enter project description: ',
        value=answers['description'],
    )

    answers['license'] = survey.routines.input(
        'Enter project license (DipDup itself is MIT-licensed.): ',
        value=answers['license'],
    )

    answers['name'] = survey.routines.input(
        "Enter author's name: ",
        value=answers['name'],
    )
    answers['email'] = survey.routines.input(
        "Enter author's email: ",
        value=answers['email'],
    )

    big_yellow_echo('Now choose versions of software you want to use.')

    _, answers['postgres_image'] = prompt_anyof(
        question='Choose PostgreSQL version. Try TimescaleDB when working with time series.',
        options=(
            'postgres:16',
            'timescale/timescaledb:latest-pg16',
            'timescale/timescaledb-ha:pg16',
        ),
        comments=(
            'PostgreSQL',
            'TimescaleDB',
            'TimescaleDB HA',
        ),
        default=0,
    )
    if 'timescaledb-ha' in answers['postgres_image']:
        answers['postgres_data_path'] = '/home/postgres/pgdata/data'
        echo(
            '`timescaledb-ha` Docker image uses `/home/postgres/pgdata/data` as a data path; generated files were updated accordingly.',
            fg='yellow',
        )

    big_yellow_echo('Miscellaneous tunables; leave default values if unsure')

    _, answers['package_manager'] = prompt_anyof(
        question='Choose package manager',
        options=(
            'uv',
            'poetry',
            'pdm',
            'none',
        ),
        comments=(
            'uv (recommended)',
            'Poetry',
            'PDM',
            '[none]',
        ),
        default=0,
    )

    answers['line_length'] = survey.routines.input(
        'Enter maximum line length for linters: ',
        value=answers['line_length'],
    )
    return answers


def answers_from_replay(path: Path) -> Answers:
    yaml_config, _ = DipDupYAMLConfig.load([path])
    yaml_config['replay'] = {
        **get_default_answers(),
        **yaml_config['replay'],
    }
    return TypeAdapter(ReplayConfig).validate_python(yaml_config).replay


def render_project(
    answers: Answers,
    force: bool = False,
) -> None:
    """Render project from template"""
    # NOTE: Common base
    _render_templates(answers, Path('base'), force)

    # NOTE: Config and handlers
    _render_templates(answers, Path(answers['template']), force)

    # NOTE: Replay to use with `init --base` and `new --replay`
    Path(answers['package']).joinpath('configs').mkdir(parents=True, exist_ok=True)
    _render(
        answers,
        template_path=Path(__file__).parent / 'templates' / 'replay.yaml.j2',
        output_path=get_package_path(answers['package']) / 'configs' / 'replay.yaml',
        force=force,
    )


def render_base(
    answers: Answers,
    force: bool = False,
    include: set[str] | None = None,
) -> None:
    """Render base from template"""
    # NOTE: Render common base
    _render_templates(
        answers=answers,
        path=Path('base'),
        force=force,
        include=include,
        exists=True,
    )
    # NOTE: Don't forget to update replay.yaml with new values
    _render(
        answers=answers,
        template_path=Path(__file__).parent / 'templates' / 'replay.yaml.j2',
        output_path=get_package_path(answers['package']) / Path('configs') / 'replay.yaml',
        force=force,
    )


def _render_templates(
    answers: Answers,
    path: Path,
    force: bool = False,
    include: set[str] | None = None,
    exists: bool = False,
) -> None:
    from jinja2 import Template

    project_path = Path(__file__).parent / 'projects' / path
    project_templates = set(project_path.glob('**/*.j2'))
    project_files = set(project_path.glob('**/*')) - project_templates

    for path in project_templates:
        template_path = path.relative_to(Path(__file__).parent)
        relative_path = str(Path(*template_path.parts[2:]))[:-3]

        if include and not any(relative_path.startswith(i) for i in include):
            continue

        output_base = get_package_path(answers['package']) if exists else Path(answers['package'])
        output_path = Path(
            output_base,
            *path.relative_to(project_path).parts,
            # NOTE: Remove ".j2" from extension
        ).with_suffix(path.suffix[:-3])
        output_path = Path(Template(str(output_path)).render(project=answers))

        _render(answers, template_path, output_path, force)

    # NOTE: If there are files without .j2 extension, just copy them
    for path in project_files:
        if path.is_dir() or path.name == 'replay.yaml':
            continue
        output_path = Path(
            get_package_path(answers['package']),
            *path.relative_to(project_path).parts,
        )
        write(output_path, path.read_bytes(), overwrite=force)


def _render(answers: Answers, template_path: Path, output_path: Path, force: bool) -> None:
    if output_path.exists() and not force:
        _logger.info('File `%s` already exists, skipping', output_path)

    _logger.info('Generating `%s`', output_path)
    template = load_template(str(template_path))
    content = ''

    if 'dipdup.yaml.j2' in str(template_path):
        content = template.render(
            project=answers,
            header=CODEGEN_HEADER,
        )
    else:
        content = template.render(
            project={k: str(v) for k, v in answers.items()},
            header=CODEGEN_HEADER,
        )

    write(output_path, content, overwrite=force)


def fill_config_from_input(
    config: dict[str, Any],
    section: str,
    section_kinds: tuple[type],
    filter: str,
) -> None:
    section_dict = config.get(section, {})
    another = False

    print(f'Configuring `{section}` section')

    while True:
        add_entity = input(f'Do you want to add{' another' if another else ''} one? (yes/no): ').strip().lower()
        if add_entity != 'yes':
            break

        # Ask for the entity name
        if section == 'database':
            name = ''
        else:
            name = input('Enter a name for the entity: ').strip()

        # Ask for the type of the entity
        print('Available entity types:')
        for i, entity_type in enumerate(section_kinds, start=1):
            kind = entity_type.__dataclass_fields__['kind'].default
            assert kind

            if filter and '.' in kind and not kind.startswith(filter):
                continue

            print(f'{i}. {kind}')

        type_choice = int(input('Choose an entity type (number): ').strip()) - 1
        # entity_type_name = list(section_kinds)[type_choice]
        entity_model = section_kinds[type_choice]

        # Gather input for the fields of the chosen type
        entity_data = {}
        for field_name, field in entity_model.__dataclass_fields__.items():
            if field_name in {'kind', 'http'}:
                continue

            default = field.default
            if default is dataclasses.MISSING:
                default = None
            elif isinstance(default, FieldInfo):
                # else:
                # print(default.__dict__)
                default = default.default_factory()

            field_value = input(f'Enter value for `{field_name}` [{field.type}] ({default}): ').strip()
            entity_data[field_name] = field_value or default

        # Validate and add the entity
        try:
            entity_instance = entity_model(**entity_data)
            section_dict[name] = entity_instance.__dict__
            another = True
        except Exception as e:
            print(f'Error: {e}. Please try again.')


def prompt_anyof(
    question: str,
    options: tuple[str, ...],
    comments: tuple[str, ...],
    default: int,
) -> tuple[int, str]:
    """Ask user to choose one of the options; returns index and value"""
    import survey
    from tabulate import tabulate

    table = tabulate(
        zip(options, comments, strict=False),
        tablefmt='plain',
    )
    index = survey.routines.select(
        question + '\n',
        options=table.split('\n'),
        index=default,
    )
    return index, options[index]


def query_survey_config(namespace: str | None) -> dict[str, Any]:
    config_dict = {}

    # NOTE: It's not a config section; we'll handle it later
    fill_config_from_input(config_dict, 'database', get_args(DatabaseConfigU), namespace)

    if namespace == 'substrate':
        fill_config_from_input(config_dict, 'runtimes', get_args(RuntimeConfigU), namespace)

    fill_config_from_input(config_dict, 'datasources', get_args(DatasourceConfigU), namespace)

    return config_dict
